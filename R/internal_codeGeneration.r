
create_code= function(name, nameVecDrvs, nameVecProc, nameVecVars, nameVecPars,
  nameSpatialLevelIndex, namesVars, namesPars, nLevels,
  code_drvs, code_proc, nProc, importFuns, newline, lang
) {

  if (lang == "f") {

    # Create code
    code=paste0("! THIS IS A GENERATED FILE - EDITING DOESN'T MAKE SENSE",newline)
    code=paste0(code,"subroutine ",name,"(time, ",nameVecVars,", ",nameVecPars,", ",nameVecDrvs,", ",nameVecProc,")",newline)
    code=paste0(code,"  ",ifelse(importFuns,"","!"),"use functions",newline)
    code=paste0(code,"  implicit none",newline)
    code=paste0(code,"  ! Inputs",newline)
    code=paste0(code,"  double precision, intent(in):: time",newline)
    code=paste0(code,"  double precision, dimension(",length(namesVars)*nLevels,"), intent(in):: ",nameVecVars,newline)
    code=paste0(code,"  double precision, dimension(",length(namesPars),"), intent(in):: ",nameVecPars,newline)
    code=paste0(code,"  ! Outputs",newline)
    code=paste0(code,"  double precision, dimension(",length(namesVars)*nLevels,"), intent(out):: ",nameVecDrvs,newline)
    code=paste0(code,"  double precision, dimension(",nProc*nLevels,"), intent(out):: ",nameVecProc,newline)
    code=paste0(code,"  ! Local",newline)
    code=paste0(code,"  integer:: spatial_level, i",newline)
    code=paste0(code,"  ! Index constants for variables",newline)
    code=paste0(code,paste0("  integer, parameter:: ",namesVars,"=",1:length(namesVars),newline,collapse=""))
    code=paste0(code,"  ! Index constants for parameters",newline)
    code=paste0(code,paste0("  integer, parameter:: ",namesPars,"=",1:length(namesPars),newline,collapse=""))
    code=paste0(code,"",newline)
    code=paste0(code,"  ! Set vector of derivatives (all spatial levels)",newline)
    code=paste0(code,"  do spatial_level = 1, ",nLevels,newline)
    code=paste0(code,"    ",nameVecDrvs,"((/(i, i=spatial_level, (",(length(namesVars)-1)*nLevels,"+spatial_level), ",nLevels,")/))","= ",nameVecDrvs,"0D(spatial_level)",newline)
    code=paste0(code,"  end do",newline)
    code=paste0(code,"  ",newline)
    code=paste0(code,"  ! Set vector of process rates (all spatial levels)",newline)
    code=paste0(code,"  do spatial_level = 1, ",nLevels,newline)
    code=paste0(code,"    ",nameVecProc,"((/(i, i=spatial_level, (",(nProc-1)*nLevels,"+spatial_level), ",nLevels,")/))","= ",nameVecProc,"0D(spatial_level)",newline)
    code=paste0(code,"  end do",newline)
    code=paste0(code,"  ",newline)
    code=paste0(code,"  contains  ! Internal functions follow",newline)
    code=paste0(code,"  ",newline)
    code=paste0(code,"  ! Function to compute the derivatives at a particular level",newline)
    code=paste0(code,"  function ",nameVecDrvs,"0D(",nameSpatialLevelIndex,")",newline)
    code=paste0(code,"  implicit none",newline)
    code=paste0(code,"  ! Inputs",newline)
    code=paste0(code,"  integer, intent(in):: ",nameSpatialLevelIndex,newline)
    code=paste0(code,"  ! Outputs",newline)
    code=paste0(code,"  double precision, dimension(",length(namesVars),"):: ",nameVecDrvs,"0D",newline)
    code=paste0(code,"  ",newline)
    code=paste0(code,"  ",code_drvs,newline)
    code=paste0(code,"  end function",newline)
    code=paste0(code,"  ",newline)
    code=paste0(code,"  ! Function to compute the process rates at a particular level",newline)
    code=paste0(code,"  function ",nameVecProc,"0D(",nameSpatialLevelIndex,")",newline)
    code=paste0(code,"  implicit none",newline)
    code=paste0(code,"  ! Inputs",newline)
    code=paste0(code,"  integer, intent(in):: ",nameSpatialLevelIndex,newline)
    code=paste0(code,"  ! Outputs",newline)
    code=paste0(code,"  double precision, dimension(",nProc,"):: ",nameVecProc,"0D",newline)
    code=paste0(code,"  ",newline)
    code=paste0(code,"  ",code_proc,newline)
    code=paste0(code,"  end function",newline)
    code=paste0(code,"end subroutine",newline)
    return(code)

  } else if (lang == "r") {

    # Create code
    code=paste0("# THIS IS A GENERATED FILE - EDITING DOESN'T MAKE SENSE",newline)
    code=paste0(code,name," = function(time, ",nameVecVars,", ",nameVecPars,") {",newline)
    code=paste0(code,"",newline)
    code=paste0(code,"  # Index constants for variables",newline)
    code=paste0(code,paste0("  ",namesVars,"=",1:length(namesVars),newline,collapse=""))
    code=paste0(code,"  # Index constants for parameters",newline)
    code=paste0(code,paste0("  ",namesPars,"=",1:length(namesPars),newline,collapse=""))
    code=paste0(code,"",newline)
    code=paste0(code,"  # Internal function to compute the derivatives at a particular level",newline)
    code=paste0(code,"  fun_",nameVecDrvs,"0D = function(",nameSpatialLevelIndex,") {",newline)
    code=paste0(code,"  ",code_drvs,newline)
    code=paste0(code,"  }",newline)
    code=paste0(code,"  ",newline)
    code=paste0(code,"  # Internal function to compute the process rates at a particular level",newline)
    code=paste0(code,"  fun_",nameVecProc,"0D = function(",nameSpatialLevelIndex,") {",newline)
    code=paste0(code,"  ",code_proc,newline)
    code=paste0(code,"  }",newline)
    code=paste0(code,"  # Set vector of derivatives (all spatial levels)",newline)
    code=paste0(code,"  #",nameVecDrvs,"= vector('numeric',",length(namesVars)*nLevels,")",newline)
    code=paste0(code,"  #for (spatial_level in 1:",nLevels,") {",newline)
    code=paste0(code,"  #  ",nameVecDrvs,"[seq(from=spatial_level, by=",nLevels,
      ", length.out=",length(namesVars),")]","= fun_",nameVecDrvs,"0D(spatial_level)",newline)
    code=paste0(code,"  #}",newline)
    code=paste0(code,"  # Next line is a replacement for the above loop code",newline)
    code=paste0(code,"  # ",nameVecDrvs," = c(t(apply(X=matrix(1:",nLevels,", ncol=1), MARGIN=1, FUN=fun_",nameVecDrvs,"0D)))",newline)
    code=paste0(code,"  # Next line is probably even more efficient. Note that the result vector ",newline)
    code=paste0(code,"  # has the correct length (number of levels * number of variables) only if",newline)
    code=paste0(code,"  # the derivative of each variable explicitly depends on a variable's value.",newline)
    code=paste0(code,"  # Then, each derivative is also a function of the spatial level.",newline)
    code=paste0(code,"  ",nameVecDrvs," = unname(fun_",nameVecDrvs,"0D(1:",nLevels,"))",newline)
    code=paste0(code,"  ",newline)
    code=paste0(code,"  # Set vector of process rates (all spatial levels)",newline)
    code=paste0(code,"  #",nameVecProc,"= vector('numeric',",nProc*nLevels,")",newline)
    code=paste0(code,"  #for (spatial_level in 1:",nLevels,") {",newline)
    code=paste0(code,"  #  ",nameVecProc,"[seq(from=spatial_level, by=",nLevels,
      ", length.out=",nProc,")]","= fun_",nameVecProc,"0D(spatial_level)",newline)
    code=paste0(code,"  #}",newline)
    code=paste0(code,"  # Next line is a replacement for the above loop code",newline)
    code=paste0(code,"  #",nameVecProc," = c(t(apply(X=matrix(1:",nLevels,", ncol=1), MARGIN=1, FUN=fun_",nameVecProc,"0D)))",newline)
    code=paste0(code,"  # Next line is probably even more efficient. Note that the result vector ",newline)
    code=paste0(code,"  # has the correct length (number of levels * number of processes) only if",newline)
    code=paste0(code,"  # each process rate explicitly depends on a variable's value.",newline)
    code=paste0(code,"  # Then, each process rate is also a function of the spatial level.",newline)
    code=paste0(code,"  ",nameVecProc," = unname(fun_",nameVecProc,"0D(1:",nLevels,"))",newline)
    code=paste0(code,"  # Return a list",newline)
    code=paste0(code,"  return(list(",nameVecDrvs,"=",nameVecDrvs,",",nameVecProc,"=",nameVecProc,"))",newline)
    code=paste0(code,"}",newline)
    return(code)

  } else {
      stop("requested language not supported")
  }
}

